/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#ifdef __GNUG__
#pragma implementation "eigenSystem.h"
#endif

#include "wx/wxprec.h"

#ifdef  __BORLANDC__
#pragma hdrstop
#endif

#include "leafpredictor.h"
#include "eigenSystem.h"

#include "tools.h"
#include "mainDialog.h"

#include "wx/textfile.h"
#include "wx/txtstrm.h"
#include "wx/msgdlg.h"

#include <vector>
#include <math.h>

EigenSystem::EigenSystem()
{
	mMeanLeaf.empty();
	mPredictedLeaf.empty();
	mEigenValues.empty();
	mEigenVectors.empty();
	mTotalVariance = 0;
	mInversionFactor = 1;
}


EigenSystem::~EigenSystem(void)
{
}


bool EigenSystem::LoadEigenFile(const wxString &eigenFile)
{
	wxTextFile in;
	wxInt32    lineCount;
	wxUint8     i;

	if(in.Open(eigenFile) == false)
		return false;

	lineCount = in.GetLineCount();
	if (lineCount != 103)
		return false;

	/*
	 * Structure of eigenfile:
	 * 0: Mean Leaf
	 * 1: Tab separated values for mean leaf x,y coordinates
	 * 2: blank line
	 * 3: Eigenvalues
	 * 4: Tab separated values for coordinate eigenvalues
	 * 5: blank line
	 * 6: Eigenvectors
	 * 7-102: 96 lines of tab separated values for coordinate eigenvectors for each of the 96 PCs generated by leafanalyser
	 *
	 * The number of x,y coordinates and therefore the eigenvalues/vectors is not defined.
	 */

	mMeanLeaf = SplitLineByDelim(in.GetLine(1), wxT("\t"));

	InvertLeaf();

	mPredictedLeaf = mMeanLeaf;
	mEigenValues = SplitLineByDelim(in.GetLine(4), wxT("\t"));
	for(i=0;i<mMeanLeaf.size();++i)
	{
		mTotalVariance += mEigenValues.at(i);
	}

	for(i=7;i<=102;++i)
	{
		mEigenVectors.push_back(SplitLineByDelim(in.GetLine(i), wxT("\t")));
	}

	return true;
}


bool EigenSystem::LoadLeafFile(const wxString &leafFile)
{
	wxTextFile in;
	wxInt32 lineCount;

	if(in.Open(leafFile) ==false)
		return false;

	lineCount = in.GetLineCount();
	if(lineCount != 1)
		return false;

	// add redundant ",x" to the line to satisfy the splitter
	mMeanLeaf = SplitLineByDelim(in.GetLine(0)+wxT(",x"), wxT(","));
	// remove the first element as it is actually a node number, NOT a coordinate
	mMeanLeaf.erase(mMeanLeaf.begin());

	InvertLeaf();

	return true;
}

std::vector<double> EigenSystem::SplitLineByDelim(const wxString &line, const wxString &delim)
{
	std::vector<double>    v;
	wxInt32                endingPos;
	wxString               choppedString;
	wxString               tmpString;
	double                 tmpDouble;

	choppedString = line;
	endingPos = choppedString.Find(delim);
	while(endingPos != wxNOT_FOUND)
	{
		tmpString = choppedString.Mid(0, endingPos);
		choppedString = choppedString.Mid(endingPos + 1, choppedString.length()- 1);
		endingPos = choppedString.Find(delim);
		tmpString.ToDouble(&tmpDouble);
		v.push_back(tmpDouble);
	}
	return v;
}


wxInt32 EigenSystem::GetNumberOfCoordinates(void)
{
	return mMeanLeaf.size();
}


double EigenSystem::GetPCSD(wxInt32 PC)
{
	return sqrt(mEigenValues.at(PC));
}


double EigenSystem::GetPCContribution(wxInt32 PC)
{
	return 100 * (mEigenValues.at(PC -1) / mTotalVariance);
}

void EigenSystem::PredictLeaf(wxUint32 PC1, wxInt32 PC1Value, wxUint32 PC2, wxInt32 PC2Value, wxUint32 PC3, wxInt32 PC3Value, wxUint32 PC4, wxInt32 PC4Value)
{
	double SD1, SD2, SD3, SD4, val1, val2, val3, val4;

	SD1 = GetPCSD(PC1);
	SD2 = GetPCSD(PC2);
	SD3 = GetPCSD(PC3);
	SD4 = GetPCSD(PC4);

	val1 = PC1Value * mInversionFactor;
	val2 = PC2Value * mInversionFactor;
	val3 = PC3Value * mInversionFactor;
	val4 = PC4Value * mInversionFactor;

	wxUint32 i;
	for(i=0;i<mMeanLeaf.size();++i)
	{
		mPredictedLeaf[i] = mMeanLeaf[i] + (mEigenVectors[PC1][i] * (SD1 * (val1 / 10))) + (mEigenVectors[PC2][i] * (SD2 * (val2 / 10))) + (mEigenVectors[PC3][i] * (SD3 * (val3 / 10))) + (mEigenVectors[PC4][i] * (SD4 * (val4 / 10)));
	}

	MainDialog::GetInstance()->SetPCMessage(wxString::Format(wxT("PC %i: %.1f SDs; PC %i: %.1f SDs; PC %i: %.1f SDs; PC %i: %.1f SDs"), PC1+1, mInversionFactor * val1/10, PC2+1, mInversionFactor * val2/10, PC3+1, mInversionFactor * val3/10, PC4+1, mInversionFactor * val4/10));
}

void EigenSystem::InvertLeaf(void)
{
	for(wxUint32 i=0;i<mMeanLeaf.size();++i)
	{
		mMeanLeaf[i] = mMeanLeaf.at(i) * -1;
	}
	mInversionFactor *= -1;
}
